# 并发

## 基础用法

> 实现多线程的两种方式

- [x] extends Thread
  - java语言特性，只支持单继承，所以一般实现runnable接口来实现多线程
- [x] implements Runnable

> 注意点

+ 线程调用start()方法是通知线程调度器，这个线程已经可以放入调度队列，等待系统调度
  + 如果直接运行run()方法，也还是在主线程中运行
  + 多个线程同时调用start()方法，执行顺序不一定按调用顺序

### 实例变量和数据安全

```java
//  不共享私有数据
//  生成三个线程实例，每个实例内部都有一个实例变量
public class PrivateDataThead extends Thread {
    private int a = 4;

     PrivateDataThead(String name) {
        super();
        setName(name);
    }

    @Override
    public void run() {
        while (a >0) {
            a--;
            Console.log(Thread.currentThread().getName()+":"+a);
        }
    }
}

//  test
public class Test {
    public static void main(String[] args){
        PrivateDataThead a=new PrivateDataThead("a");
        PrivateDataThead b=new PrivateDataThead("b");
        PrivateDataThead c=new PrivateDataThead("c");

        a.start();
        b.start();
        c.start();
    }
}

//  共享数据
public class ShareDataThread implements Runnable {
    private int i=5;
    @Override
   synchronized public void run() {
          while (i>0){
              i--;
              Console.log(i);
          }
    }
}

public class Test2 {
    public static void main(String[] args){
        ShareDataThread s=new ShareDataThread();

        new Thread(s).start();
        new Thread(s).start();
        new Thread(s).start();
        new Thread(s).start();
        new Thread(s).start();
    }
}
```

### 方法

```java
//  判断是否处于活动状态  ---已经启动，尚未结束
//  只有继承Thread的类才有
//  如果是继承Thread的类，需要注意 this和Thread.currentThreadd的区别
//  如下 知识把我们定义的线程run方法给main里面生成的thread调用
isAlive();

public class IsAliveThread extends Thread {

     IsAliveThread() {
        super();
        Console.log("----------constructor begin");
        Console.log(Thread.currentThread().getName()+":"+Thread.currentThread().isAlive()); //主线程
        Console.log(this.getName()+":"+isAlive());  // IsAliveThread
        Console.log("----------constructor end");
    }

    @Override
    public void run() {
        Console.log("----------run begin");
        Console.log(Thread.currentThread().getName()+":"+Thread.currentThread().isAlive()); // 运行线程
        Console.log(this.getName()+":"+isAlive());  // IsAliveThread
        Console.log("----------run end");
    }
}

public class Test {
    public static void main(String[] args){
        IsAliveThread s=new IsAliveThread();
        Thread a=new Thread(s);

        a.setName("aaaa");
        a.start();
    }
}
```